<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle qui tourne avec balle rebondissante</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #111;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #eee;
        font-family: system-ui, sans-serif;
      }

      canvas {
        background: #000;
        border: 2px solid #555;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      }

      .info {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 14px;
        color: #ccc;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <canvas id="scene" width="600" height="600"></canvas>
    <div class="info">
      Triangle qui tourne + balle qui rebondit à l’intérieur (HTML5 Canvas)
    </div>

    <script>
      const canvas = document.getElementById("scene");
      const ctx = canvas.getContext("2d");

      const W = canvas.width;
      const H = canvas.height;
      const cx = W / 2;
      const cy = H / 2;

      // Triangle équilatéral centré à l'origine dans un repère "local"
      const side = 320; // longueur du côté
      const h = (Math.sqrt(3) / 2) * side; // hauteur
      const tri = [
        { x: 0, y: (-2 * h) / 3 }, // sommet du haut
        { x: side / 2, y: h / 3 }, // bas droite
        { x: -side / 2, y: h / 3 }, // bas gauche
      ];

      // Balle (dans le même repère local que le triangle)
      const ball = {
        x: 0,
        y: 0,
        vx: 160, // px/s
        vy: 120, // px/s
        r: 12,
      };

      // Gravité (px/s²) dans le repère monde (vers le bas de l'écran)
      const gravity = 200;

      // Vitesse de rotation du triangle (radians par seconde)
      const angularSpeed = 0.6;
      let angle = 0;

      let lastTime = null;

      function length(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }

      // Simulation physique dans le repère local, triangle fixe.
      function updatePhysics(dt) {
        // Appliquer la gravité dans le repère monde, transformée en local
        const local_gx = gravity * Math.sin(angle);
        const local_gy = gravity * Math.cos(angle);
        ball.vx += local_gx * dt;
        ball.vy += local_gy * dt;

        // Intégration simple du mouvement
        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // Collisions avec les 3 côtés du triangle
        for (let i = 0; i < 3; i++) {
          const p1 = tri[i];
          const p2 = tri[(i + 1) % 3];

          const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
          const L = length(edge);
          if (L === 0) continue;

          // Tangente unitaire
          const t = { x: edge.x / L, y: edge.y / L };

          // Normale "intérieure" : côté gauche si vertices CCW
          const n = { x: -t.y, y: t.x };

          // Vecteur du point du segment vers le centre de la balle
          const rel = { x: ball.x - p1.x, y: ball.y - p1.y };

          // Distance signée au côté (positive = intérieur)
          const dist = rel.x * n.x + rel.y * n.y;

          // Position projetée le long du segment
          const proj = rel.x * t.x + rel.y * t.y;

          // On ne considère que la zone "en face" du segment
          if (proj < 0 || proj > L) continue;

          // Collision si la balle dépasse le mur vers l'extérieur
          if (dist < ball.r) {
            // Composante de vitesse selon la normale
            const vn = ball.vx * n.x + ball.vy * n.y;

            // Si la balle va vers l'extérieur (vn < 0), on rebondit
            if (vn < 0) {
              // Projection à l'intérieur : on recale la balle juste à distance r
              const correction = ball.r - dist;
              ball.x += n.x * correction;
              ball.y += n.y * correction;

              // Réflexion : v' = v - 2 (v·n) n
              ball.vx = ball.vx - 2 * vn * n.x;
              ball.vy = ball.vy - 2 * vn * n.y;

              // Amortissement pour éviter l'énergie infinie
              ball.vx *= 0.95;
              ball.vy *= 0.95;
            }
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);

        ctx.save();
        // On se place au centre de l'écran
        ctx.translate(cx, cy);
        // On applique la rotation globale pour triangle + balle
        ctx.rotate(angle);

        // Dessin du triangle
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.strokeStyle = "#0f0";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Dessin de la balle
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = "#f55";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }

      function loop(timestamp) {
        if (lastTime === null) lastTime = timestamp;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.033); // ~max 30 ms
        lastTime = timestamp;

        updatePhysics(dt);
        angle += angularSpeed * dt;

        draw();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    </script>
  </body>
</html>
